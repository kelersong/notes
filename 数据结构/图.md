# 图

## 图的定义与相关概念  

## 图的存储

### 邻接矩阵

### 邻接表
+ 邻接表是一种链式存储结构，它使用n个带头结点的单链表存储图


## 图的遍历

### 深度优先遍历
+ 从某个起始点开始遍历
+ 选择一个邻接点作为新的起点，如果没有邻接点，则返回上一个起始点，直到返回起点。  
+ **为了保证所有的节点都只被遍历一次，需要用一个visit[]数组保存状态，初始为false，当被访问时，变为true**
+ **代码**
  + 对每一个节点调用DFS函数
  + 在DFS中，对每一个邻接点递归调用DFS函数
  + **对每一个节点都调用DFS函数是为了保证当节点不连通时也可以全部遍历，一次DFS函数只能遍历与该起始节点连同的节点**
+ **代码实现**

~~~
void TraverseGraph(MGraph G){
    for(int i = 0;i < vexnum ; i++){
        visited[i] = false;      //默认设置为未访问状态
    }

    for(int i = 0; i< vexnum; i++){
        DFS(G[i]);
    }
}

void DFS(){
    //简单的递归实现
    //如果是用邻接矩阵存储，通过G[i][j]进行遍历
    //如果是邻接表存储，使用指针进行遍历。
}

~~~

### 广度优先遍历（BFS）
+ 原理
  + 从某一个顶点出发，先把它的所有邻接点都访问完
  + 然后按照顺序，把它的所有邻接点都作为起点进行BFS

+ 实现思路
  + 利用队列，先进先出
  + 入队 -> 出队 -> 访问 -> 所有邻接点入队
  + 直到队列为空

+ 代码实现

~~~
void TraverseGraph(MGraph G){
    // 设置visited 初始状态
    for(int i = 0;i<vexnum;i++){
        if(false){
          BFS();
        }
    }
}

BFS(){
    //利用队列来完成
    arcNode * p;
    int Queue[max_vex];
    front = rear;
    Queue[rear++] = index;
    visit[index] = true            //修改访问状态
    while(rear != front){
        //不为空
        visit(Queue[rear]);
        //入队
        p = G->VexNode[i].firstVex;   //第一个邻接点赋值给p
        while(p){
            //入队操作
            p = p->NextVex;
        }
        // 出队
        pop();

    } 
}
~~~

+ 代码实现时的一些重点
  + ***队列中存放的是int类型，不是节点结构体***
  + ***每次入队都要标记，防止重复入队***

### 为什么需要两种遍历呢？
对于不同的实际问题来说，深度遍历和广度遍历的实现效率是远远不同的

## 图的连通性  

### 一些概念
+ **子图** ：从图中选出一部分点和边构成的图  
+ **路径** ： 由一系列点构成的序列
  + **简单路径** 序列中的所有点都不相同
+ **连通** ：两个顶点之间存在路径
+ **连通分量** ：无向图中的极大连通子图
  + 极大顶点数
  + 极大边数

### 计算无向图的连通分量  
+ **实现思路** ： 在最外层调用了几次DFS，则连通分量的个数就位几   


### 判断图的连通性
+ **实现思路** ：调用一次DFS，看所有的结点是否都被访问到  

### 判断顶点之间的连通性
+ **实现思路** ： 从起点调用一次DFS,然后判断终点是否被访问到  

### 寻找最远的点
+ **实现思路** ： 利用广度遍历，最后一层的的点为最远的顶点

## 最小生成树问题

### 概念
+ 一个连通图的生成树是一个极小连通子图，它包含所有顶点，只有n-1条边
+ 如果边比n-1多的就一定会存在一个环，这就不是最小生成树了
+ 生成树可以有许多个
+ 当每一条边都有权值时，就会有最小生成树

### 算法
#### prim算法
+ 实现思路
  + 用最小的代价使生成树长大
  + 生成树每次长大都需要更新其他顶点到生成树的最小路径，这个是为了节约算法的时间复杂度
  + 定义结构体数组closest 一个是lowcost域 一个是vexcode域，记录最小的边和权重

+ 部分代码
~~~~
 struct {
  int vexcode;
  int lowcost;
}lowests[MAX_V];         //定义辅助数组
~~~~
  


#### 克鲁斯卡尔算法
+ 实现思路
  + 与prim算法不同，克鲁斯卡尔算法是对边的选择
  + 连续按照权值最小的边进行选择，当所选的边不产生回路时，就把它选中，如果构成回路就不是生成树了，对于连通性并没有帮助。
  + 克鲁斯卡尔算法的复杂度与边的个数相关，适合计算稀疏图的最小生成树



## 最短路径问题

### 单源最短路径（考察重点）
+ **算法核心** ： 
  + 每次加入一个顶点都要更新顶点到起始点的距离
  + 每次都更新是基于上一个节点的最短路径，也就是要么直接连接到单源节点，要么是通过上一个节点

+ 代码实现思路
  + 初始化辅助数组
  + 两个for循环遍历


### 多源最短路径

+ **佛洛依德算法**  
  - 动态规划 ： **将上一次的信息保存下来**
  - 每一次向路径中添加顶点，计算最小值
  - 添加顶底利用之前的数据，避免重复运算
  - 时间复杂度为n的三次方



## 拓扑排序与关键路径
+ 从有向图中选择一个入度为0的点
+ 将该点连同他相关联的边删除
+ 在算法中设置一个栈用来保存入度为0的顶点
+ 重复上述操作



