# 汇总
## 上级题目
### 第一题 ：链表相关
+ 链表的插入(头插法和尾插法)
+ 链表的删除(判断的时候用p->next )
+ 链表的排序
+ 链表的归并(无序链表先排序)
+ 倒序



### 第二题 ： 二叉树相关
+ 生成二叉树
+ 二叉树的遍历
+ 
### 第三题 ： 图相关
+ 创建一个图(包括邻接矩阵和邻接表实现)
+ 图的深度和广度遍历




## 理论题目
+ 分析时间复杂度
+ 写出算法思想
+ 写出程序代码

### 链表相关
+ 链表的插入(头插法和尾插法)
+ 链表的删除(判断的时候用p->next )
+ 链表的排序
+ 链表的归并(无序链表先排序)
  + 算法思想 : 对无序序列先进行排序，定义两个指针分别指向两个链表的第一个节点，比较两个指针数据域的值，将较大者插入新的链表中，并更新指针使其指向下一个节点，循环操作，直到有一个链表为空，将另一个链表剩余元素接入新的链表

  + 
    ~~~~
    while(p1!=0 && p2 != 0){
      if(*p1 > *p2){
        p3 -> next = p1;
        p1 = p1->next;
      }
      else{
        p3 -> next = p2;
        p2 = p2->next;
      }
      p3 = p3->next;
    }

    if(p1 == NULL){
      p3->next = p2;
    }
    else{
      p3->next = p1;
    }

    ~~~~


+ 倒序
  + 算法思想 : 使用三个指针 front cur next分别指向前一个节点，当前节点和后一个节点。初始cur指向第一个节点，front指向null。当cur不为null时，使cur的next指向front，然后将next赋给cur。最后将头结点指向cur完成逆序

    ~~~~
    front = NULL;
    cur = L.head->next;
    next = cur->next;

    while(cur){
      cur->next = front;
      front = cur;
      cur = next;
    }

    L.head->next = cur;
    ~~~~

+ 链表删除相同元素
  + 算法思想 : 对链表进行两重遍历，第一次遍历存储当前节点的值，第二次遍历将链表中的每个节点与存储的结点的值进行比较，如果相等则调用Delete函数删除元素。

  + 代码
    ~~~~
    for(int i = 0;i<L.length(),i++){
      elem1 = GetElem(i);
      for(int j = 0;j<length();){
        elem2 = GetElem(j);
        if(elem1 == elem2){
          Delete(j);
        }
        else{
          j++;
        }
      }
    }

    ~~~~


### 栈和队列
+ 入栈和出栈操作
  - base指针指向栈底，top指针指向待插入元素的位置，入栈时*top = elem，top++。 出栈时top--;

+ **栈的应用**
  - 回文诗的判定
    + 算法思想 : 将字符与栈顶元素进行比较，如果与栈顶元素相同则出栈，如果不同则入栈。直到字符串时，若栈为空则为回文诗，若栈不为空，则不是回文诗

  - 进制转换
    + 十进制转n进制。依次除以n将余数入栈。最后依次出栈则为n进制

  - 括号匹配
    + 算法思想 : 算术表达式中的括号出现的次序符合栈先进后出原则，因此适合用栈来实现。当为左括号时则入栈，当为右括号时，与栈顶元素进行匹配，若相同则出栈，不相同则报错

  - 算术表达式求值
    + 准备两个栈，一个存放操作数 另一个存放操作符。操作数栈起始为空，操作符栈起始为"#" 接下来依次读取表达式的所有字符，若是数字，则入操作数栈，若是运算符，若该运算符优先级高于栈顶元素优先级则入栈。反之则出栈，与操作数栈出栈的两个元素进行元素，结果入栈。

+ 入队和出队操作

### 数组和广义表
+ 稀疏矩阵和对称矩阵的存储方式
  + 稀疏矩阵采用三元组存储
+ **三元组的转置**
  - 两种转置的实现方法和时间复杂度
    + 直接转置法
      - 算法思想 : 按照B的列号在A中寻找对应的元素，即B中第0行元素，需要遍历A中第0列元素。
      - 时间复杂度为O(A.col*A.NUM)
    + 快速转置法
      - 算法思想 : 对A进行第一次遍历，存储各列非零元的个数，即转置后各行的非零元个数。 根据第一步的统计结果，计算B中矩阵各行的元素的起始位置。最后将交换行和列之后的三元组放在对应位置即可，并将该行的指示位置+1

+ 广义表的两种存储结构(会画图)
  + 表头表尾结构
  + 层次结构



### 树
+ 二叉树的性质
+ **二叉树的链式存储**
  + 左右孩子存储结构

+ 二叉树的遍历
  - **中序非递归**
    + 算法思想 : 使用辅助栈，首先将根节点入栈，当左孩子存在时，将左孩子入栈，直到左孩子不存在。出栈，访问根节点，并将右孩子进入下一轮循环。(因为右孩子也是根节点)
    + 代码
      ~~~~
      while(T || !IsEmpty()){
        while(T){
          Push(T);
          T = T->lchind;
        }
        if(!IsEmpty()){
          Pop();
          visit();
          T = T->rchild;
        }
      }
      ~~~~

  - 给定两种遍历，得出另一种遍历序列
    + 根据先序序列第一个结点确定根结点；在根据根结点在中序序列中分隔出左右两个子序列；对左子树和右子树分别递归使用相同方法继续分隔

  
  - 遍历的应用
    + 二叉树的深度，高度
      + 算法思想 : 使用递归，二叉树的深度等于其左右子树中较大者＋1，其左右子树的深度又等于其左右子树深度中较大值加1

      + 代码
        ~~~~
        int depth(T){
          int leftDepth,rightDepth;
          if(T == NULL) return 0;
          leftDepth = depth(T->lchild);
          rightDepth = depth(T->rchild);
          if(leftdepth >= rightDepth){
            return leftDepth+1;
          }
          else{
            return rightDepth+1;
          }
        }
        ~~~~

    + 判断叶子结点的数量
      - 算法思想 : 在遍历中判断是否为叶子节点，即左右孩子都为空
      - 代码
        ~~~~
        int Leaf(T,&count){
          Leaf(T->lchild);
          Leaf(T->rchild);
          if(T->lchild == NULL && T->rchild == NULL){
            count++;
          }
        }
        ~~~~

    + ***从根到任何一个节点的路径***
      

+ 树的存储结构
+ **哈夫曼树 代码思路都要掌握**
  + 算法思想 : 构造F{} 包括n课二叉树 其中没课二叉树只有一个根节点，从F中每次选择两颗权值最小的二叉树组成一个新的二叉树，其根节点的权值为左右孩子权值之和，反复操作直到F中只剩下一棵树，该树为哈夫曼树，哈夫曼编码即根据哈夫曼树进行编码，左孩子为‘0’ 右孩子为‘1’

  + 代码
    + 第一步 初始化前n个节点
    + 从第n+1个节点开始选择两个最小的
    + 哈夫曼编码 从叶子到根获取编码，最后要reverse一下

    ~~~~
    void HufCode(int n,int *w,HufTree T,char ** HC){
      if(b <=1 ){
        return;
      }

      T = (HufTree)malloc(2*n*sizeof(HufNode));
      if(T == NULL){
        cout << "error" <<endl;
      }
      InitHuf(T);      初始化前n个节点
      // 创建哈夫曼树
      for(int i = n+1;i<2*n;i++){
        Selete_two_small(T,s1,s2);
        HT[s1].parent = HT[s2].parent = i;
        HT[i].lchild = s1;
        HT[i].rchild = s2;
        HT[i].weight = 1 + 2;
      }


      //获取哈夫曼编码
      HC = (char**) malloc(n*sizeof(char*));
      temp = (char*)malloc(n*sizeof(char));
      for(int i = 1;i<=n;i++){
        start = 0;
        for(c= i;f = HT[c].parent;f!=0;c = f,f = HT[c].parent){
          if(f->lchild == c){
            temp[start++] = '0';
          }
          else {
            temp[start++] = '1';
          }

        }
        temp[start] = '\0'
        reverse(temp);

      }
      HC[k++] = temp;
    }
    ~~~~


### 图
+ **两种存储结构都要掌握**
+ 随堂小测
+ 深度优先遍历和广度优先遍历
  - 判断是否连通
  - 求连通分量
  - 找简单路径
+ 拓扑排序
  - **判断有向无环图**
+ 最小生成树
  - **prim算法**
+ 最短路径
  - **迪杰斯特拉算法**
  - 佛洛依德算法代码和思想
+ 关键路径查找(代码不需要掌握)

### 查找
+ 折半查找算法
+ 顺序查找算法
+ 二叉排序树(代码不需要掌握)
  - 构造平衡二叉树
+ B树的构造、插入、删除
+ 哈希表
  - 直接定值法
  - 取余
  - 解决冲突 
    + 线性探测
    + 平方探测
    + 随机探测法

### 排序
+ 希尔排序
+ 堆排序
+ 归并排序
+ 快速排序
+ 基数排序
